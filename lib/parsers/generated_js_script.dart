// GENERATED CODE - DO NOT MODIFY BY HAND
// This file is generated by tool/generate_assets.dart
// Edit bin/parsers/js_ast.js instead.

const String jsParserScript = r'''
const ts = require("typescript");
const fs = require("fs");

const filePath = process.argv[2];

if (!filePath) {
  console.error("Please provide a file path");
  process.exit(1);
}

const fileContent = fs.readFileSync(filePath, "utf-8");

const sourceFile = ts.createSourceFile(
  filePath,
  fileContent,
  ts.ScriptTarget.Latest,
  true,
);

const findings = [];

function visit(node) {
  // Extract import declarations
  if (ts.isImportDeclaration(node)) {
    const moduleSpecifier = node.moduleSpecifier.text;
    let importClause = "";

    if (node.importClause) {
      if (node.importClause.name) {
        // Default import
        importClause += node.importClause.name.text;
      }

      if (node.importClause.namedBindings) {
        if (ts.isNamedImports(node.importClause.namedBindings)) {
          // Named imports
          const elements = node.importClause.namedBindings.elements
            .map(element => element.name.text)
            .join(", ");
          importClause += `{ ${elements} }`;
        } else if (ts.isNamespaceImport(node.importClause.namedBindings)) {
          // Namespace import
          importClause += `* as ${node.importClause.namedBindings.name.text}`;
        }
      }
    }

    findings.push({
      type: 'import',
      declaration: `import ${importClause} from "${moduleSpecifier}";`
    });
  }

  // Extract class declarations
  if (ts.isClassDeclaration(node)) {
    const className = node.name ? node.name.text : 'anonymous';
    const superClass = node.heritageClauses?.find(clause => clause.token === ts.SyntaxKind.ExtendsKeyword)
      ?.types[0]?.expression?.getText(sourceFile);

    const methods = [];
    const properties = [];

    for (const member of node.members) {
      if (ts.isMethodDeclaration(member)) {
        const methodName = member.name.getText(sourceFile);
        const params = member.parameters
          ? '(' + member.parameters.map(param => {
              const name = param.name.getText(sourceFile);
              const type = param.type ? ': ' + param.type.getText(sourceFile) : '';
              const initializer = param.initializer ? ' = ' + param.initializer.getText(sourceFile) : '';
              return name + type + initializer;
            }).join(', ') + ')'
          : '()';

        const returnType = member.type ? member.type.getText(sourceFile) : '';
        const isStatic = member.modifiers?.some(mod => mod.kind === ts.SyntaxKind.StaticKeyword) || false;

        methods.push({
          name: methodName,
          params: params,
          returnType: returnType,
          isStatic: isStatic
        });
      } else if (ts.isPropertyDeclaration(member)) {
        const propName = member.name.getText(sourceFile);
        const type = member.type ? member.type.getText(sourceFile) : 'any';
        const isStatic = member.modifiers?.some(mod => mod.kind === ts.SyntaxKind.StaticKeyword) || false;

        properties.push({
          name: propName,
          type: type,
          isStatic: isStatic
        });
      }
    }

    findings.push({
      type: 'class',
      name: className,
      superClass: superClass,
      methods: methods,
      properties: properties
    });
  }

  // Extract function declarations
  if (ts.isFunctionDeclaration(node)) {
    const functionName = node.name ? node.name.text : 'anonymous';
    const params = node.parameters
      ? '(' + node.parameters.map(param => {
          const name = param.name.getText(sourceFile);
          const type = param.type ? ': ' + param.type.getText(sourceFile) : '';
          const initializer = param.initializer ? ' = ' + param.initializer.getText(sourceFile) : '';
          return name + type + initializer;
        }).join(', ') + ')'
      : '()';

    const returnType = node.type ? node.type.getText(sourceFile) : 'void';

    findings.push({
      type: 'function',
      name: functionName,
      params: params,
      returnType: returnType
    });
  }

  // Extract variable declarations
  if (ts.isVariableStatement(node)) {
    const declarationList = node.declarationList;
    let varType = 'var'; // default

    // Check the flags to determine if it's const or let
    if (declarationList.flags & ts.NodeFlags.Const) {
      varType = 'const';
    } else if (declarationList.flags & ts.NodeFlags.Let) {
      varType = 'let';
    }

    for (const declaration of declarationList.declarations) {
      const varName = declaration.name.getText(sourceFile);
      const type = declaration.type ? declaration.type.getText(sourceFile) : 'any';

      findings.push({
        type: 'variable',
        name: varName,
        type: type,
        varType: varType
      });
    }
  }

  // Extract arrow function expressions
  if (ts.isVariableDeclaration(node) && node.initializer && ts.isArrowFunction(node.initializer)) {
    const varName = node.name.getText(sourceFile);
    const arrowFunc = node.initializer;
    const params = arrowFunc.parameters
      ? '(' + arrowFunc.parameters.map(param => {
          const name = param.name.getText(sourceFile);
          const type = param.type ? ': ' + param.type.getText(sourceFile) : '';
          return name + type;
        }).join(', ') + ')'
      : '()';

    const returnType = arrowFunc.type ? arrowFunc.type.getText(sourceFile) : 'void';

    findings.push({
      type: 'function',
      name: varName,
      params: params,
      returnType: returnType
    });
  }

  // Extract call expressions (for API calls and routes)
  if (ts.isCallExpression(node)) {
    const expression = node.expression;

    if (ts.isPropertyAccessExpression(expression)) {
      const obj = expression.expression.getText(sourceFile);
      const func = expression.name.getText(sourceFile);
      if (["axios", "http", "api"].includes(obj)) {
        findings.push({
          type: 'api_call',
          description: `[Frontend API] Uses ${obj}.${func}(...)`
        });
      }

      if (
        ["app", "router"].includes(obj) &&
        ["get", "post", "put", "delete"].includes(func)
      ) {
        findings.push({
          type: 'route_definition',
          description: `[Backend Route] Defines ${obj}.${func}(...)`
        });
      }
    }
    if (ts.isIdentifier(expression) && expression.text === 'fetch') {
        findings.push({
          type: 'api_call',
          description: `[Frontend API] Uses fetch(...)`
        });
    }
  }

  ts.forEachChild(node, visit);
}

visit(sourceFile);

console.log(JSON.stringify(findings));

''';
